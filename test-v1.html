<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Vib-Ribbon Editable JSON + SVG</title>
<style>
html,body{margin:0;padding:0;overflow:hidden;height:100%;}
canvas{display:block;cursor:crosshair;}
#panel{position:fixed;top:10px;right:10px;width:220px;max-height:90vh;overflow-y:auto;background:#fff;padding:12px;font-family:monospace;font-size:14px;border-radius:6px;border:1px solid #000;z-index:100;}
#panel label{display:block;margin-bottom:6px;}
#panel input[type="range"],#panel input[type="color"]{width:100%;margin-bottom:8px;}
#panel button,#panel input[type="file"]{font-family:monospace;font-size:14px;width:100%;margin-bottom:6px;cursor:pointer;}
#togglePanel{position:fixed;top:10px;left:10px;z-index:101;font-family:monospace;font-size:14px;cursor:pointer;}
</style>
</head>
<body>
<button id="togglePanel">Show/Hide Panel</button>
<div id="panel">
    <label>Background: <input type="color" id="bgColor" value="#ffffff"></label>
    <label>Color: <input type="color" id="color" value="#000000"></label>
    <label>Width: <input type="range" id="width" min="1" max="10" value="2"></label>
    <label>Jitter: <input type="range" id="jitter" min="0" max="10" value="2"></label>
    <label>Wobble: <input type="range" id="wobble" min="0" max="10" value="2"></label>
    <label>Wobble Speed: <input type="range" id="wobbleSpeed" min="0" max="1" step="0.01" value="0.3"></label>
    <label>Pencil Layers: <input type="range" id="pencilLayers" min="1" max="5" value="3"></label>
    <label>Grain Intensity: <input type="range" id="grainIntensity" min="0" max="1" step="0.1" value="0.4"></label>
    <input type="file" id="importJSON" accept=".json">
    <input type="file" id="importSVG" accept=".svg">
    <button id="undo">Undo</button>
    <button id="clear">Clear</button>
    <button id="resetDefaults">Reset Defaults</button>
    <button id="exportJSON">Export JSON</button>
    <button id="importJSONBtn">Import JSON</button>
    <button id="importSVGBtn">Import SVG</button>
    <button id="exportSVG">Export SVG</button>
</div>

<script src="https://cdnjs.cloudflare.com/ajax/libs/pixi.js/7.2.4/pixi.min.js"></script>
<script>
// ================= CONFIG =================
const DEFAULT_CONFIG={color:0x000000,width:2,jitter:2,wobble:2,wobbleSpeed:0.3,bgColor:0xFFFFFF,pencilLayers:3,grainIntensity:0.4};
let STROKE_CONFIG={...DEFAULT_CONFIG};

// PIXI app
const app=new PIXI.Application({resizeTo:window,backgroundColor:STROKE_CONFIG.bgColor,antialias:false});
document.body.appendChild(app.view);

// strokes
let strokes=[],time=0;
const strokeContainer=new PIXI.Container();
app.stage.addChild(strokeContainer);

// ================= STROKE CLASS =================
class Stroke{
    constructor(color,width){
        this.points=[];
        this.gfx=new PIXI.Graphics();
        this.color=color;
        this.width=width;
        this.randomOffsets=[];
        strokeContainer.addChild(this.gfx);
    }
    addPoint(x,y){
        this.points.push({x,y});
        this.randomOffsets.push(Math.random()*1000);
    }
    draw(index,time){
        const pts=this.points,length=pts.length;
        if(length<2){this.gfx.clear();return;}
        this.gfx.clear();
        const numLayers=STROKE_CONFIG.pencilLayers;
        for(let l=0;l<numLayers;l++){
            const alpha=(l===0)?0.8:(l===1)?0.4:0.2;
            const lw=this.width*(1+l*0.3);
            for(let i=0;i<length-1;i++){
                const p0=pts[i],p1=pts[i+1];
                const startA=(i<length*0.1)?i/(length*0.1):1;
                const endA=(i>length*0.9)?(length-i)/(length*0.1):1;
                const baseA=Math.min(startA,endA);
                const grain=0.3+Math.random()*STROKE_CONFIG.grainIntensity;
                const finalA=baseA*alpha*grain;
                const wf=(i===0||i===length-2)?0.05:1;
                const lo=l*0.5;
                const wob0=Math.sin(time+i*STROKE_CONFIG.wobbleSpeed+index+this.randomOffsets[i]+lo)*STROKE_CONFIG.wobble*wf;
                const wob1=Math.cos(time+i*STROKE_CONFIG.wobbleSpeed+index+this.randomOffsets[i]+lo)*STROKE_CONFIG.wobble*wf;
                const wob0n=Math.sin(time+(i+1)*STROKE_CONFIG.wobbleSpeed+index+this.randomOffsets[i+1]+lo)*STROKE_CONFIG.wobble*wf;
                const wob1n=Math.cos(time+(i+1)*STROKE_CONFIG.wobbleSpeed+index+this.randomOffsets[i+1]+lo)*STROKE_CONFIG.wobble*wf;
                const mj=0.3;
                const j0=(Math.random()-0.5)*STROKE_CONFIG.jitter*wf+(Math.random()-0.5)*mj;
                const j1=(Math.random()-0.5)*STROKE_CONFIG.jitter*wf+(Math.random()-0.5)*mj;
                const j0n=(Math.random()-0.5)*STROKE_CONFIG.jitter*wf+(Math.random()-0.5)*mj;
                const j1n=(Math.random()-0.5)*STROKE_CONFIG.jitter*wf+(Math.random()-0.5)*mj;
                const x0=p0.x+wob0+j0,y0=p0.y+wob1+j1;
                const x1=p1.x+wob0n+j0n,y1=p1.y+wob1n+j1n;
                this.gfx.lineStyle(lw,this.color,finalA);
                this.gfx.moveTo(x0,y0); this.gfx.lineTo(x1,y1);
                if(Math.random()<0.1){this.gfx.lineStyle(lw*0.3,this.color,finalA*0.5);this.gfx.moveTo(x0+(Math.random()-0.5)*2,y0+(Math.random()-0.5)*2);this.gfx.lineTo(x1+(Math.random()-0.5)*2,y1+(Math.random()-0.5)*2);}
            }
        }
    }
}

// ================= DRAW EVENTS (MOUSE + TOUCH) =================
let activeStrokes = new Map();

// Mouse events
app.view.addEventListener("mousedown", e => {
    const stroke=new Stroke(STROKE_CONFIG.color,STROKE_CONFIG.width);
    strokes.push(stroke);
    stroke.addPoint(e.offsetX,e.offsetY);
    activeStrokes.set("mouse", stroke);
});
app.view.addEventListener("mousemove", e => {
    const stroke=activeStrokes.get("mouse");
    if(stroke) stroke.addPoint(e.offsetX,e.offsetY);
});
app.view.addEventListener("mouseup", ()=>{activeStrokes.delete("mouse");});

// Touch events
app.view.addEventListener("touchstart", e => {
    e.preventDefault();
    for (let t of e.changedTouches) {
        const rect=app.view.getBoundingClientRect();
        const x=t.clientX-rect.left;
        const y=t.clientY-rect.top;
        const stroke=new Stroke(STROKE_CONFIG.color,STROKE_CONFIG.width);
        strokes.push(stroke);
        stroke.addPoint(x,y);
        activeStrokes.set(t.identifier, stroke);
    }
},{passive:false});
app.view.addEventListener("touchmove", e => {
    e.preventDefault();
    for (let t of e.changedTouches) {
        const stroke=activeStrokes.get(t.identifier);
        if(stroke){
            const rect=app.view.getBoundingClientRect();
            stroke.addPoint(t.clientX-rect.left,t.clientY-rect.top);
        }
    }
},{passive:false});
app.view.addEventListener("touchend", e => {
    e.preventDefault();
    for (let t of e.changedTouches) activeStrokes.delete(t.identifier);
},{passive:false});
app.view.addEventListener("touchcancel", e => {
    e.preventDefault();
    for (let t of e.changedTouches) activeStrokes.delete(t.identifier);
},{passive:false});

// ================= PANEL EVENTS =================
const panel=document.getElementById('panel');
document.getElementById('togglePanel').addEventListener('click',()=>{panel.style.display=panel.style.display==='none'?'block':'none';});
document.getElementById('undo').addEventListener('click',()=>{if(strokes.length>0) strokeContainer.removeChild(strokes.pop().gfx);});
document.getElementById('clear').addEventListener('click',()=>{strokes.forEach(s=>strokeContainer.removeChild(s.gfx));strokes=[];});
document.getElementById('resetDefaults').addEventListener('click',()=>{
    STROKE_CONFIG={...DEFAULT_CONFIG};
    document.getElementById('color').value='#000000';
    document.getElementById('width').value=DEFAULT_CONFIG.width;
    document.getElementById('jitter').value=DEFAULT_CONFIG.jitter;
    document.getElementById('wobble').value=DEFAULT_CONFIG.wobble;
    document.getElementById('wobbleSpeed').value=DEFAULT_CONFIG.wobbleSpeed;
    document.getElementById('bgColor').value='#ffffff';
    document.getElementById('pencilLayers').value=DEFAULT_CONFIG.pencilLayers;
    document.getElementById('grainIntensity').value=DEFAULT_CONFIG.grainIntensity;
    app.renderer.backgroundColor=STROKE_CONFIG.bgColor;
});

// ================= LIVE CONTROLS =================
['color','width','jitter','wobble','wobbleSpeed','bgColor','pencilLayers','grainIntensity'].forEach(id=>{
    document.getElementById(id).addEventListener('input',e=>{
        const v=e.target.value;
        switch(id){case'color':STROKE_CONFIG.color=parseInt(v.replace('#',''),16);break;case'width':STROKE_CONFIG.width=Number(v);break;case'jitter':STROKE_CONFIG.jitter=Number(v);break;case'wobble':STROKE_CONFIG.wobble=Number(v);break;case'wobbleSpeed':STROKE_CONFIG.wobbleSpeed=Number(v);break;case'bgColor':STROKE_CONFIG.bgColor=parseInt(v.replace('#',''),16);app.renderer.backgroundColor=STROKE_CONFIG.bgColor;break;case'pencilLayers':STROKE_CONFIG.pencilLayers=Number(v);break;case'grainIntensity':STROKE_CONFIG.grainIntensity=Number(v);break;}
    });
});

// ================= JSON EXPORT =================
function exportJSON(){
    const data=strokes.map(s=>({color:s.color,width:s.width,points:s.points}));
    const blob=new Blob([JSON.stringify(data,null,2)],{type:"application/json"});
    const url=URL.createObjectURL(blob);
    const a=document.createElement('a'); a.href=url; a.download='drawing.json'; a.click();
    URL.revokeObjectURL(url);
}

// ================= JSON IMPORT =================
document.getElementById('importJSONBtn').addEventListener('click',()=>{document.getElementById('importJSON').click();});
document.getElementById('importJSON').addEventListener('change',async e=>{
    const file=e.target.files[0]; if(!file) return;
    const text=await file.text();
    const data=JSON.parse(text);
    data.forEach(obj=>{
        const stroke=new Stroke(obj.color,obj.width);
        obj.points.forEach(p=>stroke.addPoint(p.x,p.y));
        stroke.randomOffsets=stroke.points.map(()=>Math.random()*1000);
        strokes.push(stroke);
    });
});

// ================= SVG IMPORT =================
document.getElementById('importSVGBtn').addEventListener('click',()=>{document.getElementById('importSVG').click();});
document.getElementById('importSVG').addEventListener('change',async e=>{
    const file=e.target.files[0]; if(!file) return;
    const text=await file.text();
    const parser=new DOMParser();
    const svgDoc=parser.parseFromString(text,"image/svg+xml");
    const paths=[...svgDoc.querySelectorAll('path')];
    paths.forEach(path=>{
        const d=path.getAttribute('d'); if(!d) return;
        const commands=d.match(/[ML][^ML]+/g); if(!commands) return;
        const stroke=new Stroke(STROKE_CONFIG.color,STROKE_CONFIG.width);
        commands.forEach(cmd=>{
            const [x,y]=cmd.slice(1).trim().split(/[ ,]/).map(Number);
            if(!isNaN(x)&&!isNaN(y)) stroke.addPoint(x,y);
        });
        stroke.randomOffsets=stroke.points.map(()=>Math.random()*1000);
        strokes.push(stroke);
    });
});

// ================= SVG EXPORT =================
function exportSVG() {
    const svgNS = "http://www.w3.org/2000/svg";
    const svgEl = document.createElementNS(svgNS,'svg');
    svgEl.setAttribute('width',app.screen.width);
    svgEl.setAttribute('height',app.screen.height);
    svgEl.setAttribute('xmlns','http://www.w3.org/2000/svg');

    strokes.forEach(s=>{
        const pathEl=document.createElementNS(svgNS,'path');
        const d = s.points.map((p,i)=>`${i===0?'M':'L'} ${p.x} ${p.y}`).join(' ');
        pathEl.setAttribute('d',d);
        pathEl.setAttribute('stroke','#'+s.color.toString(16).padStart(6,'0'));
        pathEl.setAttribute('stroke-width',s.width);
        pathEl.setAttribute('fill','none');
        pathEl.setAttribute('stroke-linecap','round');
        pathEl.setAttribute('stroke-linejoin','round');
        svgEl.appendChild(pathEl);
    });

    const serializer = new XMLSerializer();
    const blob = new Blob([serializer.serializeToString(svgEl)],{type:"image/svg+xml"});
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href=url;
    a.download='drawing.svg';
    a.click();
    URL.revokeObjectURL(url);
}

// ================= BUTTONS =================
document.getElementById('exportJSON').addEventListener('click',exportJSON);
document.getElementById('exportSVG').addEventListener('click',exportSVG);

// ================= RENDER LOOP =================
app.ticker.add(()=>{time+=0.1; strokes.forEach((s,i)=>s.draw(i,time));});
</script>
</body>
</html>